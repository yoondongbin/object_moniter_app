---
globs: Jenkinsfile,deploy.sh,docker-compose*.yml,mobile/scripts/*.sh
description: CI/CD 파이프라인 및 배포 자동화 가이드
---

# CI/CD 파이프라인 및 배포 자동화 가이드

## 🚀 CI/CD 아키텍처 개요

### 파이프라인 구성
- **Jenkins**: 빌드 자동화 및 배포 오케스트레이션
- **Docker**: 백엔드 컨테이너화 및 배포
- **Shell Scripts**: 모바일 앱 빌드 자동화
- **환경 분리**: Development, Staging, Production

### 주요 파일
- **파이프라인 정의**: [Jenkinsfile](mdc:Jenkinsfile)
- **Docker 설정**: [docker-compose.yml](mdc:docker-compose.yml), [docker-compose.prod.yml](mdc:docker-compose.prod.yml)
- **배포 스크립트**: [deploy.sh](mdc:deploy.sh)
- **모바일 빌드**: [mobile/scripts/](mdc:mobile/scripts/) 디렉토리

## 🏗️ Jenkins 파이프라인 구조

### 파라미터 기반 빌드
```groovy
// Jenkinsfile - 빌드 파라미터 정의
parameters {
    choice(
        name: 'APP_ENV', 
        choices: ['development', 'staging', 'production'], 
        description: '🌍 빌드할 환경을 선택하세요'
    )
    booleanParam(name: 'BUILD_BACKEND', defaultValue: true, description: '🐳 백엔드 Docker 이미지 빌드')
    booleanParam(name: 'BUILD_ANDROID', defaultValue: true, description: '🤖 Android APK 빌드')
    booleanParam(name: 'BUILD_IOS', defaultValue: true, description: '🍎 iOS 앱 빌드')
    booleanParam(name: 'DEPLOY_BACKEND', defaultValue: false, description: '🚀 백엔드 서버에 배포')
    booleanParam(name: 'CLEAN_BUILD', defaultValue: false, description: '🧹 완전 클린 빌드')
}
```

### 스테이지별 실행 흐름
1. **환경 준비**: 빌드 환경 검증 및 소스코드 체크아웃
2. **백엔드 빌드**: Docker 이미지 생성 및 레지스트리 푸시
3. **모바일 의존성**: Node.js 패키지 설치 및 환경 설정
4. **Android 빌드**: Gradle을 통한 APK 생성
5. **iOS 빌드**: Xcode를 통한 앱 생성 (macOS 에이전트 필요)
6. **배포**: 서버에 Docker 컨테이너 배포

## 🐳 Docker 배포 패턴

### 개발 환경 (docker-compose.yml)
```yaml
# 로컬 개발용 Docker Compose
version: '3.8'
services:
  backend:
    build: ./back_end
    ports:
      - "5010:5010"
    environment:
      - FLASK_ENV=development
      - MYSQL_HOST=db
    depends_on:
      - db
    volumes:
      - ./back_end/uploads:/app/uploads

  db:
    image: mariadb:10.6
    environment:
      MYSQL_ROOT_PASSWORD: rootpassword
      MYSQL_DATABASE: object_monitor
    ports:
      - "3306:3306"
    volumes:
      - mysql_data:/var/lib/mysql

volumes:
  mysql_data:
```

### 프로덕션 환경 (docker-compose.prod.yml)
```yaml
# 프로덕션용 Docker Compose
version: '3.8'
services:
  backend:
    image: ${BACKEND_IMAGE:-object-monitor-backend:latest}
    restart: unless-stopped
    environment:
      - FLASK_ENV=production
      - MYSQL_HOST=db
      - MYSQL_PASSWORD=${MYSQL_PASSWORD}
    depends_on:
      - db
      - redis
    networks:
      - app-network

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./ssl:/etc/nginx/ssl:ro
    depends_on:
      - backend
    networks:
      - app-network

  db:
    image: mariadb:10.6
    restart: unless-stopped
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
      MYSQL_DATABASE: ${MYSQL_DATABASE}
    volumes:
      - mysql_data:/var/lib/mysql
    networks:
      - app-network

  redis:
    image: redis:7-alpine
    restart: unless-stopped
    networks:
      - app-network

networks:
  app-network:
    driver: bridge

volumes:
  mysql_data:
```

## 📱 모바일 빌드 자동화

### Android 빌드 스크립트 패턴
```bash
# mobile/scripts/build-release.sh - Android 릴리스 빌드
#!/bin/bash
set -e

ENV=${1:-staging}
echo "🤖 Android ${ENV} 환경 릴리스 빌드 시작..."

# 환경 설정 적용
cp .env.${ENV} .env

# 의존성 설치
yarn install --frozen-lockfile

# Android 빌드
cd android

# 키스토어 검증
if [ ! -f "app/my-upload-key.keystore" ]; then
    echo "❌ 프로덕션 키스토어가 없습니다!"
    exit 1
fi

# Gradle 빌드 실행
./gradlew clean
./gradlew assembleRelease --no-daemon --stacktrace

# APK 파일 확인 및 이름 변경
APK_PATH="app/build/outputs/apk/release/app-release.apk"
if [ -f "$APK_PATH" ]; then
    NEW_NAME="app-${ENV}-$(date +%Y%m%d-%H%M%S).apk"
    cp "$APK_PATH" "app/build/outputs/apk/release/$NEW_NAME"
    echo "✅ APK 생성 완료: $NEW_NAME"
else
    echo "❌ APK 생성 실패!"
    exit 1
fi
```

### iOS 빌드 스크립트 패턴
```bash
# mobile/scripts/build-ios.sh - iOS 빌드
#!/bin/bash
set -e

MODE=${1:-staging}
echo "🍎 iOS ${MODE} 환경 빌드 시작..."

# macOS 환경 확인
if [ "$(uname)" != "Darwin" ]; then
    echo "❌ iOS 빌드는 macOS에서만 가능합니다!"
    exit 1
fi

# 환경 설정 적용
cp .env.${MODE} .env

# CocoaPods 설치
echo "📦 CocoaPods 설치 중..."
npx pod-install ios

# Xcode 빌드
echo "🏗️ Xcode 빌드 실행 중..."
WORKSPACE="ios/mobile.xcworkspace"
SCHEME="mobile"

xcodebuild \
    -workspace "$WORKSPACE" \
    -scheme "$SCHEME" \
    -configuration Release \
    -sdk iphonesimulator \
    -derivedDataPath ios/build \
    clean build

# 빌드 결과 확인
APP_PATH="ios/build/Build/Products/Release-iphonesimulator/mobile.app"
if [ -d "$APP_PATH" ]; then
    echo "✅ iOS 앱 빌드 완료"
    
    # 앱 압축
    cd "$(dirname "$APP_PATH")"
    ZIP_NAME="mobile-${MODE}-$(date +%Y%m%d-%H%M%S).app.zip"
    zip -r "$ZIP_NAME" mobile.app
    echo "📦 앱 압축 완료: $ZIP_NAME"
else
    echo "❌ iOS 앱 빌드 실패!"
    exit 1
fi
```

## 🔐 보안 및 인증서 관리

### Jenkins Credentials 설정
```groovy
// Jenkinsfile - 보안 정보 사용
withCredentials([
    file(credentialsId: 'android_keystore', variable: 'KEYSTORE_FILE'),
    string(credentialsId: 'ANDROID_KEYSTORE_PASSWORD', variable: 'STORE_PWD'),
    string(credentialsId: 'ANDROID_KEY_ALIAS', variable: 'KEY_ALIAS'),
    string(credentialsId: 'ANDROID_KEY_PASSWORD', variable: 'KEY_PWD')
]) {
    // 키스토어 파일 복사 및 사용
    sh '''
        cp "$KEYSTORE_FILE" mobile/android/app/my-upload-key.keystore
        
        # local.properties 생성
        cat > mobile/android/local.properties << EOF
MYAPP_UPLOAD_STORE_PASSWORD=${STORE_PWD}
MYAPP_UPLOAD_KEY_PASSWORD=${KEY_PWD}
EOF
        
        # 빌드 실행
        cd mobile/android
        ./gradlew assembleRelease
    '''
}
```

### 환경 변수 주입
```bash
# mobile/scripts/ci-make-env.sh - CI/CD 환경 변수 생성
#!/bin/bash
set -euo pipefail

# 필수 환경변수 확인
if [ -z "${APP_ENV:-}" ] || [ -z "${API_BASE_URL:-}" ]; then
    echo "❌ 필수 환경변수가 설정되지 않았습니다!"
    echo "필요한 변수: APP_ENV, API_BASE_URL"
    exit 1
fi

# 환경별 기본값 설정
case "$APP_ENV" in
    "development")
        TIMEOUT="${TIMEOUT:-10000}"
        DEBUG_MODE="${DEBUG_MODE:-true}"
        LOG_LEVEL="${LOG_LEVEL:-debug}"
        ;;
    "staging")
        TIMEOUT="${TIMEOUT:-15000}"
        DEBUG_MODE="${DEBUG_MODE:-false}"
        LOG_LEVEL="${LOG_LEVEL:-info}"
        ;;
    "production")
        TIMEOUT="${TIMEOUT:-20000}"
        DEBUG_MODE="${DEBUG_MODE:-false}"
        LOG_LEVEL="${LOG_LEVEL:-warn}"
        ;;
esac

# .env 파일 생성
cat > .env.${APP_ENV} << EOF
APP_ENV=${APP_ENV}
API_BASE_URL=${API_BASE_URL}
TIMEOUT=${TIMEOUT}
DEBUG_MODE=${DEBUG_MODE}
LOG_LEVEL=${LOG_LEVEL}
BUILD_NUMBER=${BUILD_NUMBER:-dev}
BUILD_TIMESTAMP=$(date '+%Y%m%d-%H%M%S')
EOF

# 현재 환경 파일로 복사
cp .env.${APP_ENV} .env

echo "✅ 환경 설정 파일 생성 완료: .env.${APP_ENV}"
```

## 🚀 배포 자동화

### 서버 배포 스크립트
```bash
# deploy.sh - 서버 배포 자동화
#!/bin/bash
set -e

ENV=${1:-staging}
IMAGE_TAG=${2:-latest}

echo "🚀 ${ENV} 환경 배포 시작..."

# 환경별 설정 로드
case "$ENV" in
    "staging")
        COMPOSE_FILE="docker-compose.staging.yml"
        ;;
    "production")
        COMPOSE_FILE="docker-compose.prod.yml"
        ;;
    *)
        echo "❌ 지원하지 않는 환경: $ENV"
        exit 1
        ;;
esac

# 환경 변수 설정
export BACKEND_IMAGE="object-monitor-backend:${IMAGE_TAG}"
export MYSQL_PASSWORD="${MYSQL_PASSWORD:-defaultpassword}"
export MYSQL_ROOT_PASSWORD="${MYSQL_ROOT_PASSWORD:-rootpassword}"
export MYSQL_DATABASE="${MYSQL_DATABASE:-object_monitor}"

# Docker 이미지 업데이트
echo "📥 Docker 이미지 업데이트 중..."
docker-compose -f "$COMPOSE_FILE" pull backend

# 서비스 재시작
echo "🔄 서비스 재시작 중..."
docker-compose -f "$COMPOSE_FILE" up -d backend

# 헬스체크
echo "🏥 헬스체크 수행 중..."
sleep 30

for i in {1..5}; do
    if curl -f http://localhost/api/health; then
        echo "✅ 배포 완료 및 헬스체크 성공!"
        break
    else
        if [ $i -eq 5 ]; then
            echo "❌ 헬스체크 실패!"
            docker-compose -f "$COMPOSE_FILE" logs backend
            exit 1
        fi
        echo "⏳ 헬스체크 재시도 ($i/5)..."
        sleep 10
    fi
done

echo "🎉 ${ENV} 환경 배포가 성공적으로 완료되었습니다!"
```

## 📊 모니터링 및 로깅

### 빌드 상태 모니터링
```groovy
// Jenkinsfile - 빌드 결과 알림
post {
    success {
        script {
            def summary = """
🎉 빌드 성공!
환경: ${params.APP_ENV}
빌드: #${BUILD_NUMBER}
소요시간: ${currentBuild.durationString}
아티팩트: APK, iOS App, Docker Image
            """
            
            // Slack 알림 (선택적)
            if (env.SLACK_WEBHOOK_URL) {
                slackSend(
                    channel: '#ci-cd',
                    color: 'good',
                    message: summary
                )
            }
        }
    }
    
    failure {
        script {
            def failureMessage = """
💥 빌드 실패!
환경: ${params.APP_ENV}
빌드: #${BUILD_NUMBER}
로그를 확인하여 문제를 해결해주세요.
            """
            
            // 실패 알림
            if (env.SLACK_WEBHOOK_URL) {
                slackSend(
                    channel: '#ci-cd',
                    color: 'danger',
                    message: failureMessage
                )
            }
        }
    }
    
    always {
        // 아티팩트 보관
        archiveArtifacts artifacts: 'mobile/android/app/build/outputs/apk/release/*.apk', allowEmptyArchive: true
        archiveArtifacts artifacts: 'mobile/ios/build/Build/Products/Release-iphonesimulator/*.zip', allowEmptyArchive: true
        
        // 빌드 로그 정리
        sh '''
            # 임시 파일 정리
            rm -f mobile/.env mobile/.env.*
            rm -f mobile/android/app/my-upload-key.keystore
            rm -f mobile/android/local.properties
            
            # Docker 정리
            docker system prune -f || true
        '''
    }
}
```

### 배포 상태 확인
```bash
# 배포 후 상태 확인 스크립트
check_deployment_status() {
    local env=$1
    local max_attempts=10
    local attempt=1
    
    echo "🔍 ${env} 환경 배포 상태 확인 중..."
    
    while [ $attempt -le $max_attempts ]; do
        echo "시도 $attempt/$max_attempts..."
        
        # 서비스 상태 확인
        if docker-compose ps | grep -q "Up"; then
            echo "✅ 컨테이너 실행 중"
            
            # API 헬스체크
            if curl -f http://localhost/api/health >/dev/null 2>&1; then
                echo "✅ API 헬스체크 성공"
                return 0
            else
                echo "⚠️ API 응답 없음"
            fi
        else
            echo "⚠️ 컨테이너 실행 상태 확인 필요"
        fi
        
        sleep 30
        ((attempt++))
    done
    
    echo "❌ 배포 상태 확인 실패"
    return 1
}
```

## 🔧 트러블슈팅 가이드

### 일반적인 빌드 오류 해결
```bash
# Android 빌드 오류 해결
fix_android_build_issues() {
    echo "🔧 Android 빌드 문제 해결 중..."
    
    # Gradle 캐시 정리
    cd mobile/android
    ./gradlew clean
    ./gradlew cleanBuildCache
    
    # 의존성 재설치
    cd ..
    rm -rf node_modules
    yarn install
    
    # React Native 캐시 정리
    npx react-native start --reset-cache &
    sleep 5
    kill %1
    
    echo "✅ Android 빌드 환경 정리 완료"
}

# iOS 빌드 오류 해결
fix_ios_build_issues() {
    echo "🔧 iOS 빌드 문제 해결 중..."
    
    # iOS 빌드 캐시 정리
    rm -rf mobile/ios/build
    rm -rf mobile/ios/Pods
    
    # CocoaPods 재설치
    cd mobile
    npx pod-install ios
    
    echo "✅ iOS 빌드 환경 정리 완료"
}
```

### 배포 롤백 절차
```bash
# 배포 롤백 스크립트
rollback_deployment() {
    local env=$1
    local previous_tag=$2
    
    echo "🔄 ${env} 환경 롤백 시작..."
    
    # 이전 이미지로 롤백
    export BACKEND_IMAGE="object-monitor-backend:${previous_tag}"
    docker-compose -f "docker-compose.${env}.yml" up -d backend
    
    # 롤백 확인
    sleep 30
    if curl -f http://localhost/api/health; then
        echo "✅ 롤백 완료"
    else
        echo "❌ 롤백 실패 - 수동 확인 필요"
        exit 1
    fi
}
```