---
globs: back_end/**/*.py
description: Flask 백엔드 개발 패턴 및 베스트 프랙티스
---

# Flask 백엔드 개발 패턴

## 🏗️ 백엔드 아키텍처 개요

### 프로젝트 구조
- **진입점**: [back_end/app.py](mdc:back_end/app.py) - Flask 앱 초기화 및 실행
- **설정**: [back_end/config.py](mdc:back_end/config.py) - 환경별 설정 관리
- **모델**: [back_end/models.py](mdc:back_end/models.py) - SQLAlchemy 데이터베이스 모델
- **라우트**: [back_end/routes.py](mdc:back_end/routes.py) - API 엔드포인트 정의
- **AI 서비스**: [back_end/detection_service.py](mdc:back_end/detection_service.py) - YOLOv8 객체 탐지

### 기술 스택
- **웹 프레임워크**: Flask + Flask-CORS + Flask-JWT-Extended
- **데이터베이스**: MySQL (개발: SQLite 대체 가능)
- **AI 모델**: YOLOv8 (Ultralytics)
- **이미지 처리**: PIL, OpenCV
- **배포**: Docker + Gunicorn

## 🔧 Flask 앱 초기화 패턴

### 앱 팩토리 패턴
```python
# app.py - 표준 Flask 앱 초기화
from flask import Flask
from flask_cors import CORS
from flask_jwt_extended import JWTManager
from config import config
from models import db

def create_app(config_name='development'):
    """Flask 앱 생성 및 설정"""
    app = Flask(__name__)
    
    # 환경별 설정 로드
    app.config.from_object(config[config_name])
    
    # 확장 기능 초기화
    db.init_app(app)
    CORS(app, origins=["*"])  # 개발용 - 프로덕션에서는 제한 필요
    
    jwt = JWTManager(app)
    
    # 블루프린트 등록
    from routes import auth_bp, objects_bp, logs_bp, notifications_bp
    app.register_blueprint(auth_bp, url_prefix='/api/auth')
    app.register_blueprint(objects_bp, url_prefix='/api/objects')
    app.register_blueprint(logs_bp, url_prefix='/api/logs')
    app.register_blueprint(notifications_bp, url_prefix='/api/notifications')
    
    return app

# 앱 실행
if __name__ == '__main__':
    app = create_app()
    with app.app_context():
        db.create_all()  # 테이블 생성
        create_default_data()  # 기본 데이터 생성
    
    app.run(host='0.0.0.0', port=5010, debug=True)
```

### 환경별 설정 관리
```python
# config.py - 환경별 설정 클래스
import os
from dotenv import load_dotenv

load_dotenv()

class Config:
    """기본 설정"""
    SECRET_KEY = os.getenv('SECRET_KEY', 'dev-secret-key')
    JWT_SECRET_KEY = os.getenv('JWT_SECRET_KEY', 'jwt-secret-key')
    JWT_ACCESS_TOKEN_EXPIRES = timedelta(hours=1)
    JWT_REFRESH_TOKEN_EXPIRES = timedelta(days=30)
    
    # 데이터베이스 설정
    MYSQL_HOST = os.getenv('MYSQL_HOST', 'localhost')
    MYSQL_PORT = int(os.getenv('MYSQL_PORT', 3306))
    MYSQL_USER = os.getenv('MYSQL_USER', 'root')
    MYSQL_PASSWORD = os.getenv('MYSQL_PASSWORD', '')
    MYSQL_DATABASE = os.getenv('MYSQL_DATABASE', 'object_monitor')
    
    @property
    def SQLALCHEMY_DATABASE_URI(self):
        # MySQL 연결 실패 시 SQLite 대체
        try:
            return f"mysql+pymysql://{self.MYSQL_USER}:{self.MYSQL_PASSWORD}@{self.MYSQL_HOST}:{self.MYSQL_PORT}/{self.MYSQL_DATABASE}"
        except:
            return 'sqlite:///fallback.db'

class DevelopmentConfig(Config):
    """개발 환경 설정"""
    DEBUG = True
    SQLALCHEMY_ECHO = True  # SQL 쿼리 로깅

class ProductionConfig(Config):
    """프로덕션 환경 설정"""
    DEBUG = False
    SQLALCHEMY_ECHO = False

config = {
    'development': DevelopmentConfig,
    'production': ProductionConfig,
    'default': DevelopmentConfig
}
```

## 🗄️ 데이터베이스 모델 패턴

### SQLAlchemy 모델 정의
```python
# models.py - 데이터베이스 모델
from flask_sqlalchemy import SQLAlchemy
from datetime import datetime
from werkzeug.security import generate_password_hash, check_password_hash

db = SQLAlchemy()

class User(db.Model):
    """사용자 모델"""
    __tablename__ = 'users'
    
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False, index=True)
    email = db.Column(db.String(120), unique=True, nullable=False, index=True)
    password_hash = db.Column(db.String(255), nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    # 관계 설정
    objects = db.relationship('Object', backref='user', lazy=True, cascade='all, delete-orphan')
    
    def set_password(self, password):
        """비밀번호 해시화 저장"""
        self.password_hash = generate_password_hash(password)
    
    def check_password(self, password):
        """비밀번호 검증"""
        return check_password_hash(self.password_hash, password)
    
    def to_dict(self):
        """딕셔너리 변환 (JSON 응답용)"""
        return {
            'id': self.id,
            'username': self.username,
            'email': self.email,
            'created_at': self.created_at.isoformat()
        }

class Object(db.Model):
    """모니터링 객체 모델"""
    __tablename__ = 'objects'
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    description = db.Column(db.Text)
    status = db.Column(db.Enum('active', 'inactive'), default='active')
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # 관계 설정
    detections = db.relationship('Detection', backref='object', lazy=True, cascade='all, delete-orphan')
    
    def to_dict(self):
        return {
            'id': self.id,
            'name': self.name,
            'description': self.description,
            'status': self.status,
            'user_id': self.user_id,
            'created_at': self.created_at.isoformat(),
            'updated_at': self.updated_at.isoformat()
        }

class Detection(db.Model):
    """탐지 결과 모델"""
    __tablename__ = 'detections'
    
    id = db.Column(db.Integer, primary_key=True)
    object_id = db.Column(db.Integer, db.ForeignKey('objects.id'), nullable=False)
    detection_type = db.Column(db.String(50), nullable=False)
    object_class = db.Column(db.String(50), nullable=False)
    confidence = db.Column(db.Float, nullable=False)
    
    # 바운딩 박스 좌표
    bbox_x = db.Column(db.Integer)
    bbox_y = db.Column(db.Integer)
    bbox_width = db.Column(db.Integer)
    bbox_height = db.Column(db.Integer)
    
    danger_level = db.Column(db.Enum('safe', 'low', 'medium', 'high'), default='safe')
    image_path = db.Column(db.String(255))
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    def to_dict(self):
        return {
            'id': self.id,
            'object_id': self.object_id,
            'detection_type': self.detection_type,
            'object_class': self.object_class,
            'confidence': self.confidence,
            'bbox_x': self.bbox_x,
            'bbox_y': self.bbox_y,
            'bbox_width': self.bbox_width,
            'bbox_height': self.bbox_height,
            'danger_level': self.danger_level,
            'image_path': self.image_path,
            'created_at': self.created_at.isoformat()
        }
```

## 🛣️ API 라우트 패턴

### 블루프린트 구조화
```python
# routes.py - API 엔드포인트 정의
from flask import Blueprint, request, jsonify
from flask_jwt_extended import jwt_required, create_access_token, get_jwt_identity
from models import db, User, Object, Detection

# 블루프린트 생성
auth_bp = Blueprint('auth', __name__)
objects_bp = Blueprint('objects', __name__)

@auth_bp.route('/login', methods=['POST'])
def login():
    """사용자 로그인"""
    try:
        data = request.get_json()
        
        # 입력 검증
        if not data or not data.get('username') or not data.get('password'):
            return jsonify({'error': '사용자명과 비밀번호를 입력해주세요.'}), 400
        
        # 사용자 조회 및 비밀번호 확인
        user = User.query.filter_by(username=data['username']).first()
        if not user or not user.check_password(data['password']):
            return jsonify({'error': '잘못된 사용자명 또는 비밀번호입니다.'}), 401
        
        # JWT 토큰 생성
        access_token = create_access_token(identity=user.id)
        refresh_token = create_refresh_token(identity=user.id)
        
        return jsonify({
            'access_token': access_token,
            'refresh_token': refresh_token,
            'user': user.to_dict(),
            'message': '로그인 성공'
        }), 200
        
    except Exception as e:
        return jsonify({'error': f'로그인 처리 중 오류가 발생했습니다: {str(e)}'}), 500

@objects_bp.route('', methods=['GET'])
@jwt_required()
def get_objects():
    """사용자의 객체 목록 조회"""
    try:
        user_id = get_jwt_identity()
        objects = Object.query.filter_by(user_id=user_id).all()
        
        return jsonify({
            'success': True,
            'data': [obj.to_dict() for obj in objects]
        }), 200
        
    except Exception as e:
        return jsonify({'error': f'객체 목록 조회 중 오류가 발생했습니다: {str(e)}'}), 500

@objects_bp.route('/<int:object_id>', methods=['GET'])
@jwt_required()
def get_object(object_id):
    """특정 객체 상세 조회"""
    try:
        user_id = get_jwt_identity()
        obj = Object.query.filter_by(id=object_id, user_id=user_id).first()
        
        if not obj:
            return jsonify({'error': '객체를 찾을 수 없습니다.'}), 404
        
        return jsonify(obj.to_dict()), 200
        
    except Exception as e:
        return jsonify({'error': f'객체 조회 중 오류가 발생했습니다: {str(e)}'}), 500

@objects_bp.route('/<int:object_id>/detect', methods=['POST'])
@jwt_required()
def detect_object(object_id):
    """객체 탐지 실행"""
    try:
        user_id = get_jwt_identity()
        obj = Object.query.filter_by(id=object_id, user_id=user_id).first()
        
        if not obj:
            return jsonify({'error': '객체를 찾을 수 없습니다.'}), 404
        
        # AI 탐지 서비스 호출
        from detection_service import run_detection
        detection_result = run_detection(object_id)
        
        return jsonify(detection_result.to_dict()), 200
        
    except Exception as e:
        return jsonify({'error': f'객체 탐지 중 오류가 발생했습니다: {str(e)}'}), 500
```

## 🤖 AI 서비스 패턴

### YOLOv8 통합
```python
# detection_service.py - AI 객체 탐지 서비스
import os
from ultralytics import YOLO
from PIL import Image
import cv2
import numpy as np
from datetime import datetime
from models import db, Detection, Object

class DetectionService:
    def __init__(self):
        """YOLOv8 모델 초기화"""
        self.model_path = 'yolov8n.pt'  # 모델 파일 경로
        self.model = None
        self.load_model()
    
    def load_model(self):
        """YOLO 모델 로드"""
        try:
            if os.path.exists(self.model_path):
                self.model = YOLO(self.model_path)
                print(f"✅ YOLO 모델 로드 완료: {self.model_path}")
            else:
                print(f"❌ 모델 파일을 찾을 수 없습니다: {self.model_path}")
        except Exception as e:
            print(f"❌ 모델 로드 실패: {str(e)}")
    
    def detect_objects(self, image_path: str, object_id: int) -> Detection:
        """이미지에서 객체 탐지 수행"""
        try:
            if not self.model:
                raise Exception("YOLO 모델이 로드되지 않았습니다.")
            
            # 이미지 로드 및 전처리
            image = cv2.imread(image_path)
            if image is None:
                raise Exception(f"이미지를 로드할 수 없습니다: {image_path}")
            
            # YOLO 추론 실행
            results = self.model(image)
            
            # 결과 처리
            detections = []
            for result in results:
                boxes = result.boxes
                if boxes is not None:
                    for box in boxes:
                        # 바운딩 박스 좌표
                        x1, y1, x2, y2 = box.xyxy[0].cpu().numpy()
                        confidence = float(box.conf[0].cpu().numpy())
                        class_id = int(box.cls[0].cpu().numpy())
                        class_name = self.model.names[class_id]
                        
                        # 위험도 계산
                        danger_level = self.calculate_danger_level(class_name, confidence)
                        
                        # 탐지 결과 저장
                        detection = Detection(
                            object_id=object_id,
                            detection_type='yolo_detection',
                            object_class=class_name,
                            confidence=confidence,
                            bbox_x=int(x1),
                            bbox_y=int(y1),
                            bbox_width=int(x2 - x1),
                            bbox_height=int(y2 - y1),
                            danger_level=danger_level,
                            image_path=image_path
                        )
                        
                        db.session.add(detection)
                        detections.append(detection)
            
            db.session.commit()
            
            # 가장 높은 신뢰도의 탐지 결과 반환
            if detections:
                return max(detections, key=lambda d: d.confidence)
            else:
                # 탐지된 객체가 없는 경우 기본 결과 생성
                return self.create_no_detection_result(object_id, image_path)
                
        except Exception as e:
            db.session.rollback()
            raise Exception(f"객체 탐지 실패: {str(e)}")
    
    def calculate_danger_level(self, class_name: str, confidence: float) -> str:
        """객체 클래스와 신뢰도를 기반으로 위험도 계산"""
        # 위험한 객체 클래스 정의
        dangerous_classes = ['knife', 'gun', 'fire', 'person']
        
        if class_name in dangerous_classes:
            if confidence > 0.8:
                return 'high'
            elif confidence > 0.6:
                return 'medium'
            else:
                return 'low'
        else:
            return 'safe'
    
    def create_no_detection_result(self, object_id: int, image_path: str) -> Detection:
        """탐지된 객체가 없을 때 기본 결과 생성"""
        detection = Detection(
            object_id=object_id,
            detection_type='no_detection',
            object_class='none',
            confidence=0.0,
            danger_level='safe',
            image_path=image_path
        )
        
        db.session.add(detection)
        db.session.commit()
        return detection

# 전역 서비스 인스턴스
detection_service = DetectionService()

def run_detection(object_id: int) -> Detection:
    """객체 탐지 실행 (라우트에서 호출)"""
    # 임시 이미지 생성 또는 기존 이미지 사용
    image_path = f"uploads/detections/{object_id}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.jpg"
    
    # 실제 구현에서는 카메라나 업로드된 이미지 사용
    # 여기서는 데모용 더미 이미지 생성
    create_dummy_image(image_path)
    
    return detection_service.detect_objects(image_path, object_id)

def create_dummy_image(image_path: str):
    """데모용 더미 이미지 생성"""
    os.makedirs(os.path.dirname(image_path), exist_ok=True)
    
    # 640x480 크기의 더미 이미지 생성
    dummy_image = np.random.randint(0, 255, (480, 640, 3), dtype=np.uint8)
    cv2.imwrite(image_path, dummy_image)
```

## 🔒 보안 및 에러 처리

### JWT 토큰 관리
```python
# JWT 설정 및 에러 핸들러
from flask_jwt_extended import JWTManager

jwt = JWTManager(app)

@jwt.expired_token_loader
def expired_token_callback(jwt_header, jwt_payload):
    """만료된 토큰 처리"""
    return jsonify({'error': '토큰이 만료되었습니다. 다시 로그인해주세요.'}), 401

@jwt.invalid_token_loader
def invalid_token_callback(error):
    """유효하지 않은 토큰 처리"""
    return jsonify({'error': '유효하지 않은 토큰입니다.'}), 401

@jwt.unauthorized_loader
def missing_token_callback(error):
    """토큰 누락 처리"""
    return jsonify({'error': '인증이 필요합니다.'}), 401
```

### 전역 에러 핸들러
```python
# 전역 에러 처리
@app.errorhandler(404)
def not_found(error):
    return jsonify({'error': '요청한 리소스를 찾을 수 없습니다.'}), 404

@app.errorhandler(500)
def internal_error(error):
    db.session.rollback()
    return jsonify({'error': '서버 내부 오류가 발생했습니다.'}), 500

@app.errorhandler(Exception)
def handle_exception(e):
    """모든 예외 처리"""
    db.session.rollback()
    app.logger.error(f'예외 발생: {str(e)}')
    return jsonify({'error': '예상치 못한 오류가 발생했습니다.'}), 500
```

## 🐳 Docker 배포 패턴

### Dockerfile 최적화
```dockerfile
# Dockerfile - 멀티스테이지 빌드
FROM python:3.12-slim as builder

# 시스템 의존성 설치
RUN apt-get update && apt-get install -y \
    gcc \
    g++ \
    libgl1-mesa-glx \
    libglib2.0-0 \
    && rm -rf /var/lib/apt/lists/*

# Python 의존성 설치
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 프로덕션 스테이지
FROM python:3.12-slim

# 런타임 의존성만 설치
RUN apt-get update && apt-get install -y \
    libgl1-mesa-glx \
    libglib2.0-0 \
    && rm -rf /var/lib/apt/lists/*

# 빌드 스테이지에서 패키지 복사
COPY --from=builder /usr/local/lib/python3.12/site-packages /usr/local/lib/python3.12/site-packages
COPY --from=builder /usr/local/bin /usr/local/bin

# 앱 코드 복사
WORKDIR /app
COPY . .

# 권한 설정
RUN chmod +x app.py

# 포트 노출
EXPOSE 5010

# Gunicorn으로 실행
CMD ["gunicorn", "--bind", "0.0.0.0:5010", "--workers", "4", "app:app"]
```