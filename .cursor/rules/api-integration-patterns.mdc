---
globs: mobile/src/services/**/*.ts,mobile/src/utils/axiosInstance.ts,mobile/src/types/api*.ts
description: API 통신 및 데이터 처리 패턴 가이드
---

# API 통신 및 데이터 처리 패턴

## 🌐 API 아키텍처 개요

### 백엔드 API 구조
백엔드는 Flask 기반으로 다음과 같은 엔드포인트를 제공합니다:
- **인증**: `/api/auth/*` - 로그인, 회원가입, 토큰 갱신
- **객체 관리**: `/api/objects/*` - 모니터링 객체 CRUD
- **탐지 결과**: `/api/objects/{id}/detections` - AI 탐지 결과
- **알림**: `/api/notifications/*` - 실시간 알림 관리

### API 응답 패턴
```typescript
// 표준 API 응답 구조 (mobile/src/types/api.ts 참조)
interface ApiResponse<T = any> {
  success: boolean;
  data?: T;
  message?: string;
  error?: string;
}

// 목록 조회 응답 (래핑된 데이터)
GET /api/objects → { success: true, data: ObjectItem[] }

// 단일 조회 응답 (직접 데이터)
GET /api/objects/1 → ObjectItem

// 에러 응답
{ success: false, error: "인증이 필요합니다" }
```

## 🔧 Axios 인스턴스 설정

### 중앙화된 HTTP 클라이언트
모든 API 호출은 [mobile/src/utils/axiosInstance.ts](mdc:mobile/src/utils/axiosInstance.ts)를 통해 수행:

```typescript
import axios from 'axios';
import { getApiConfig } from '../config/apiConfig';

// 환경별 설정 적용
const config = getApiConfig();

const axiosInstance = axios.create({
  baseURL: config.BASE_URL,
  timeout: config.TIMEOUT,
  headers: {
    'Content-Type': 'application/json',
  },
});

// 요청 인터셉터: JWT 토큰 자동 첨부
axiosInstance.interceptors.request.use(async (config) => {
  if (!config.skipAuth) {
    const token = await getAccessToken();
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
  }
  return config;
});

// 응답 인터셉터: 토큰 만료 시 자동 갱신
axiosInstance.interceptors.response.use(
  (response) => response,
  async (error) => {
    if (error.response?.status === 401) {
      // 토큰 갱신 로직
      const newToken = await refreshAccessToken();
      if (newToken) {
        // 원래 요청 재시도
        return axiosInstance.request(error.config);
      }
    }
    return Promise.reject(error);
  }
);
```

### 환경별 API 설정
[mobile/src/config/apiConfig.ts](mdc:mobile/src/config/apiConfig.ts)에서 환경별 API 설정 관리:

```typescript
export const API_CONFIG = {
  DEVELOPMENT: {
    BASE_URL: 'http://192.168.1.169:5010',
    TIMEOUT: 10000,
  },
  STAGING: {
    BASE_URL: 'https://staging-api.your-domain.com',
    TIMEOUT: 15000,
  },
  PRODUCTION: {
    BASE_URL: 'https://api.your-domain.com',
    TIMEOUT: 15000,
  },
};
```

## 🔐 인증 패턴

### JWT 토큰 관리
```typescript
// authApi.ts - 인증 서비스
export const authService = {
  // 로그인: skipAuth 옵션으로 토큰 없이 요청
  async login(loginData: LoginRequest): Promise<AuthResponse> {
    const response = await axiosInstance.post<AuthResponse>(
      API_ENDPOINTS.AUTH.LOGIN, 
      loginData,
      { skipAuth: true } // 로그인 시에는 토큰 불필요
    );
    
    // 토큰 저장
    await storeTokens(response.data.access_token, response.data.refresh_token);
    return response.data;
  },

  // 토큰 갱신: Authorization 헤더에 refresh token 전송
  async refreshToken(): Promise<string> {
    const refreshToken = await getRefreshToken();
    const response = await axios.post(
      `${config.BASE_URL}/api/auth/refresh`,
      null, // body는 null
      { headers: { Authorization: `Bearer ${refreshToken}` } }
    );
    return response.data.access_token;
  },
};
```

### 토큰 저장소 패턴
```typescript
// tokenStorage.ts - 안전한 토큰 저장
import AsyncStorage from '@react-native-async-storage/async-storage';

const TOKEN_KEYS = {
  ACCESS_TOKEN: 'access_token',
  REFRESH_TOKEN: 'refresh_token',
} as const;

export const storeTokens = async (accessToken: string, refreshToken: string) => {
  await Promise.all([
    AsyncStorage.setItem(TOKEN_KEYS.ACCESS_TOKEN, accessToken),
    AsyncStorage.setItem(TOKEN_KEYS.REFRESH_TOKEN, refreshToken),
  ]);
};

export const getAccessToken = async (): Promise<string | null> => {
  return AsyncStorage.getItem(TOKEN_KEYS.ACCESS_TOKEN);
};

export const clearTokens = async (): Promise<void> => {
  await AsyncStorage.multiRemove([TOKEN_KEYS.ACCESS_TOKEN, TOKEN_KEYS.REFRESH_TOKEN]);
};
```

## 📊 데이터 처리 패턴

### API 서비스 구조화
각 도메인별로 API 서비스를 분리:

```typescript
// objectApi.ts - 객체 관리 API
export const objectService = {
  // 목록 조회 (래핑된 응답)
  async getObjects(): Promise<ObjectItem[]> {
    const response = await axiosInstance.get<ApiResponse<ObjectItem[]>>(
      API_ENDPOINTS.OBJECTS.LIST
    );
    return response.data.data || [];
  },

  // 단일 조회 (직접 응답)
  async getObject(id: number): Promise<ObjectItem> {
    const response = await axiosInstance.get<ObjectItem>(
      API_ENDPOINTS.OBJECTS.DETAIL(id)
    );
    return response.data;
  },

  // 생성
  async createObject(objectData: CreateObjectRequest): Promise<ObjectItem> {
    const response = await axiosInstance.post<ObjectItem>(
      API_ENDPOINTS.OBJECTS.CREATE,
      objectData
    );
    return response.data;
  },
};

// detectionApi.ts - 탐지 결과 API
export const detectionService = {
  // 객체별 탐지 결과 조회
  async getObjectDetections(objectId: number): Promise<DetectionResult[]> {
    const response = await axiosInstance.get<ApiResponse<DetectionResult[]>>(
      API_ENDPOINTS.DETECTIONS.LIST_BY_OBJECT(objectId)
    );
    return response.data.data || [];
  },

  // 탐지 실행
  async executeDetection(objectId: number): Promise<DetectionResult> {
    const response = await axiosInstance.post<DetectionResult>(
      API_ENDPOINTS.OBJECTS.DETECT(objectId)
    );
    return response.data;
  },
};
```

### 에러 처리 표준화
```typescript
// 컴포넌트에서 API 호출 시 표준 에러 처리
const handleApiCall = async () => {
  try {
    setIsLoading(true);
    const result = await objectService.getObjects();
    setObjects(result);
  } catch (error: any) {
    // 서버 에러 메시지 우선 사용
    let errorMessage = '데이터를 불러오는데 실패했습니다.';
    if (error.response?.data?.error) {
      errorMessage = error.response.data.error;
    } else if (error.response?.data?.detail) {
      errorMessage = error.response.data.detail;
    } else if (error.message) {
      errorMessage = error.message;
    }
    
    Alert.alert('오류', errorMessage);
    console.error('API 호출 실패:', error);
  } finally {
    setIsLoading(false);
  }
};
```

## 🔄 실시간 데이터 처리

### 폴링 패턴
```typescript
// 주기적 데이터 갱신
const usePolling = (apiCall: () => Promise<any>, interval: number = 5000) => {
  const [data, setData] = useState(null);
  
  useEffect(() => {
    const fetchData = async () => {
      try {
        const result = await apiCall();
        setData(result);
      } catch (error) {
        console.error('폴링 에러:', error);
      }
    };

    fetchData(); // 초기 로드
    const intervalId = setInterval(fetchData, interval);
    
    return () => clearInterval(intervalId);
  }, [apiCall, interval]);

  return data;
};

// 사용 예시
const recentDetections = usePolling(() => detectionService.getRecentDetections(), 10000);
```

### 캐시 및 상태 관리
```typescript
// React Query 패턴 (선택적)
const useObjectsQuery = () => {
  return useQuery({
    queryKey: ['objects'],
    queryFn: objectService.getObjects,
    staleTime: 5 * 60 * 1000, // 5분 캐시
    refetchOnWindowFocus: false,
  });
};
```

## 📱 오프라인 지원

### 네트워크 상태 확인
```typescript
import NetInfo from '@react-native-community/netinfo';

const useNetworkStatus = () => {
  const [isConnected, setIsConnected] = useState<boolean>(true);

  useEffect(() => {
    const unsubscribe = NetInfo.addEventListener(state => {
      setIsConnected(state.isConnected ?? false);
    });

    return unsubscribe;
  }, []);

  return isConnected;
};

// API 호출 전 네트워크 상태 확인
const handleApiCallWithNetworkCheck = async () => {
  if (!isConnected) {
    Alert.alert('네트워크 오류', '인터넷 연결을 확인해주세요.');
    return;
  }
  
  // API 호출 진행
  await apiCall();
};
```

## 🧪 API 테스트 패턴

### Mock 데이터 활용
```typescript
// __mocks__/apiService.ts
export const mockObjectService = {
  getObjects: jest.fn().mockResolvedValue([
    { id: 1, name: '테스트 객체', status: 'active' }
  ]),
  
  createObject: jest.fn().mockResolvedValue(
    { id: 2, name: '새 객체', status: 'active' }
  ),
};

// 테스트에서 사용
import { mockObjectService } from '../__mocks__/apiService';

describe('ObjectListScreen', () => {
  it('객체 목록을 올바르게 표시해야 함', async () => {
    const { getByText } = render(<ObjectListScreen />);
    
    await waitFor(() => {
      expect(getByText('테스트 객체')).toBeTruthy();
    });
    
    expect(mockObjectService.getObjects).toHaveBeenCalledTimes(1);
  });
});
```